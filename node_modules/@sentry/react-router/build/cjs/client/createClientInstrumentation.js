Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const browser = require('@sentry/browser');
const core = require('@sentry/core');
const debugBuild = require('../common/debug-build.js');
const utils = require('../common/utils.js');

const WINDOW = core.GLOBAL_OBJ ;

// Tracks active numeric navigation span to prevent duplicate spans when popstate fires
let currentNumericNavigationSpan;

const SENTRY_CLIENT_INSTRUMENTATION_FLAG = '__sentryReactRouterClientInstrumentationUsed';
// Intentionally never reset - once set, instrumentation API handles all navigations for the session.
const SENTRY_NAVIGATE_HOOK_INVOKED_FLAG = '__sentryReactRouterNavigateHookInvoked';
const SENTRY_POPSTATE_LISTENER_ADDED_FLAG = '__sentryReactRouterPopstateListenerAdded';

const GLOBAL_WITH_FLAGS = core.GLOBAL_OBJ ;

/**
 * Options for creating Sentry client instrumentation.
 */

/**
 * Creates a Sentry client instrumentation for React Router's instrumentation API.
 * @experimental
 */
function createSentryClientInstrumentation(
  options = {},
) {
  const { captureErrors = true } = options;

  debugBuild.DEBUG_BUILD && core.debug.log('React Router client instrumentation API created.');

  return {
    router(router) {
      // Set the flag when React Router actually invokes our instrumentation.
      // This ensures the flag is only set in Library Mode (where hooks run),
      // not in Framework Mode (where hooks are never called).
      // See: https://github.com/remix-run/react-router/discussions/13749
      GLOBAL_WITH_FLAGS[SENTRY_CLIENT_INSTRUMENTATION_FLAG] = true;
      debugBuild.DEBUG_BUILD && core.debug.log('React Router client instrumentation API router hook registered.');

      // Add popstate listener for browser back/forward navigation (persists for session, one listener only)
      if (!GLOBAL_WITH_FLAGS[SENTRY_POPSTATE_LISTENER_ADDED_FLAG] && WINDOW.addEventListener) {
        GLOBAL_WITH_FLAGS[SENTRY_POPSTATE_LISTENER_ADDED_FLAG] = true;

        WINDOW.addEventListener('popstate', () => {
          const client = core.getClient();
          if (!client) {
            currentNumericNavigationSpan = undefined;
            return;
          }

          const pathname = WINDOW.location?.pathname || '/';

          // If there's an active numeric navigation span, update it instead of creating a duplicate
          if (currentNumericNavigationSpan) {
            if (currentNumericNavigationSpan.isRecording()) {
              currentNumericNavigationSpan.updateName(pathname);
            }
            currentNumericNavigationSpan = undefined;
            return;
          }

          // Only create a new span for actual browser back/forward button clicks
          browser.startBrowserTracingNavigationSpan(client, {
            name: pathname,
            attributes: {
              [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
              [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',
              [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react_router.instrumentation_api',
              'navigation.type': 'browser.popstate',
            },
          });
        });

        debugBuild.DEBUG_BUILD && core.debug.log('React Router popstate listener registered for browser back/forward navigation.');
      }

      router.instrument({
        async navigate(callNavigate, info) {
          // navigate(0) triggers a page reload - skip span creation, but still capture errors
          // (navigation can be rejected before reload, e.g., by a navigation guard)
          if (info.to === 0) {
            const result = await callNavigate();
            if (result.status === 'error' && result.error instanceof Error) {
              utils.captureInstrumentationError(result, captureErrors, 'react_router.navigate', {
                'http.url': info.currentUrl,
              });
            }
            return;
          }

          GLOBAL_WITH_FLAGS[SENTRY_NAVIGATE_HOOK_INVOKED_FLAG] = true;

          // Handle numeric navigations (navigate(-1), navigate(1), etc.)
          if (typeof info.to === 'number') {
            const client = core.getClient();
            let navigationSpan;

            if (client) {
              const navigationType = info.to < 0 ? 'router.back' : 'router.forward';
              const currentPathname = WINDOW.location?.pathname || info.currentUrl;

              navigationSpan = browser.startBrowserTracingNavigationSpan(client, {
                name: currentPathname,
                attributes: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react_router.instrumentation_api',
                  'navigation.type': navigationType,
                },
              });

              // Store ref so popstate listener can update it instead of creating a duplicate
              currentNumericNavigationSpan = navigationSpan;
            }

            try {
              const result = await callNavigate();

              if (navigationSpan && WINDOW.location) {
                navigationSpan.updateName(WINDOW.location.pathname);
              }

              if (result.status === 'error' && result.error instanceof Error) {
                if (navigationSpan) {
                  navigationSpan.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                }
                utils.captureInstrumentationError(result, captureErrors, 'react_router.navigate', {
                  'http.url': WINDOW.location?.pathname || info.currentUrl,
                });
              }
            } finally {
              currentNumericNavigationSpan = undefined;
            }
            return;
          }

          // Handle string navigations (e.g., navigate('/about'))
          const client = core.getClient();
          const toPath = String(info.to);
          let navigationSpan;

          if (client) {
            navigationSpan = browser.startBrowserTracingNavigationSpan(client, {
              name: toPath,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react_router.instrumentation_api',
                'navigation.type': 'router.navigate',
              },
            });
          }

          const result = await callNavigate();
          if (result.status === 'error' && result.error instanceof Error) {
            if (navigationSpan) {
              navigationSpan.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
            }
            utils.captureInstrumentationError(result, captureErrors, 'react_router.navigate', {
              'http.url': toPath,
            });
          }
          return;
        },

        async fetch(callFetch, info) {
          await core.startSpan(
            {
              name: `Fetcher ${info.fetcherKey}`,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.fetcher',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callFetch();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.fetcher', {
                  'http.url': info.href,
                });
              }
            },
          );
        },
      });
    },

    route(route) {
      route.instrument({
        async loader(callLoader, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const routePattern = utils.normalizeRoutePath(utils.getPattern(info)) || urlPath;

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.client_loader',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callLoader();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.client_loader', {
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async action(callAction, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const routePattern = utils.normalizeRoutePath(utils.getPattern(info)) || urlPath;

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.client_action',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callAction();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.client_action', {
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async middleware(callMiddleware, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const routePattern = utils.normalizeRoutePath(utils.getPattern(info)) || urlPath;

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.client_middleware',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callMiddleware();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.client_middleware', {
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async lazy(callLazy) {
          await core.startSpan(
            {
              name: 'Lazy Route Load',
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.client_lazy',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callLazy();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.client_lazy', {});
              }
            },
          );
        },
      });
    },
  };
}

/**
 * Check if React Router's instrumentation API is being used on the client.
 * @experimental
 */
function isClientInstrumentationApiUsed() {
  return !!GLOBAL_WITH_FLAGS[SENTRY_CLIENT_INSTRUMENTATION_FLAG];
}

/**
 * Check if React Router's instrumentation API's navigate hook was invoked.
 * @experimental
 */
function isNavigateHookInvoked() {
  return !!GLOBAL_WITH_FLAGS[SENTRY_NAVIGATE_HOOK_INVOKED_FLAG];
}

exports.createSentryClientInstrumentation = createSentryClientInstrumentation;
exports.isClientInstrumentationApiUsed = isClientInstrumentationApiUsed;
exports.isNavigateHookInvoked = isNavigateHookInvoked;
//# sourceMappingURL=createClientInstrumentation.js.map
