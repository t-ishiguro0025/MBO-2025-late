Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const api = require('@opentelemetry/api');
const core$1 = require('@opentelemetry/core');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const serverGlobals = require('./serverGlobals.js');

/**
 * Wraps the original handleRequest function to add Sentry instrumentation.
 *
 * @param originalHandle - The original handleRequest function to wrap
 * @returns A wrapped version of the handle request function with Sentry instrumentation
 */
function wrapSentryHandleRequest(
  originalHandle,
) {
  return async function sentryInstrumentedHandleRequest(
    request,
    responseStatusCode,
    responseHeaders,
    routerContext,
    loadContext,
  ) {
    const parameterizedPath =
      routerContext?.staticHandlerContext?.matches?.[routerContext.staticHandlerContext.matches.length - 1]?.route.path;

    const activeSpan = core.getActiveSpan();
    const rootSpan = activeSpan ? core.getRootSpan(activeSpan) : undefined;

    if (parameterizedPath && rootSpan) {
      // Normalize route name - avoid "//" for root routes
      const routeName = parameterizedPath.startsWith('/') ? parameterizedPath : `/${parameterizedPath}`;

      // The express instrumentation writes on the rpcMetadata and that ends up stomping on the `http.route` attribute.
      const rpcMetadata = core$1.getRPCMetadata(api.context.active());

      if (rpcMetadata?.type === core$1.RPCType.HTTP) {
        rpcMetadata.route = routeName;
      }

      const transactionName = `${request.method} ${routeName}`;

      core.updateSpanName(rootSpan, transactionName);
      core.getCurrentScope().setTransactionName(transactionName);

      // Set route attributes - acts as fallback for lazy-only routes when using instrumentation API
      // Don't override origin when instrumentation API is used (preserve instrumentation_api origin)
      if (serverGlobals.isInstrumentationApiUsed()) {
        rootSpan.setAttributes({
          [semanticConventions.ATTR_HTTP_ROUTE]: routeName,
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
        });
      } else {
        rootSpan.setAttributes({
          [semanticConventions.ATTR_HTTP_ROUTE]: routeName,
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.react_router.request_handler',
        });
      }
    }

    try {
      // Type guard to call the correct overload based on loadContext type
      if (isRouterContextProvider(loadContext)) {
        // loadContext is RouterContextProvider
        return await (originalHandle )(
          request,
          responseStatusCode,
          responseHeaders,
          routerContext,
          loadContext,
        );
      } else {
        // loadContext is AppLoadContext
        return await (originalHandle )(
          request,
          responseStatusCode,
          responseHeaders,
          routerContext,
          loadContext,
        );
      }
    } finally {
      await core.flushIfServerless();
    }

    /**
     * Helper type guard to determine if the context is a RouterContextProvider.
     *
     * @param ctx - The context to check
     * @returns True if the context is a RouterContextProvider
     */
    function isRouterContextProvider(ctx) {
      return typeof (ctx )?.get === 'function';
    }
  };
}

// todo(v11): remove this
/** @deprecated Use `wrapSentryHandleRequest` instead. */
const sentryHandleRequest = wrapSentryHandleRequest;

exports.sentryHandleRequest = sentryHandleRequest;
exports.wrapSentryHandleRequest = wrapSentryHandleRequest;
//# sourceMappingURL=wrapSentryHandleRequest.js.map
