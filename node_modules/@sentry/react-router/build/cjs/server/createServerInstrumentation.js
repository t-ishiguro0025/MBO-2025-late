Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const api = require('@opentelemetry/api');
const core$1 = require('@opentelemetry/core');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const debugBuild = require('../common/debug-build.js');
const utils = require('../common/utils.js');
const serverGlobals = require('./serverGlobals.js');

/**
 * Options for creating Sentry server instrumentation.
 */

/**
 * Creates a Sentry server instrumentation for React Router's instrumentation API.
 * @experimental
 */
function createSentryServerInstrumentation(
  options = {},
) {
  const { captureErrors = true } = options;

  serverGlobals.markInstrumentationApiUsed();
  debugBuild.DEBUG_BUILD && core.debug.log('React Router server instrumentation API enabled.');

  return {
    handler(handler) {
      handler.instrument({
        async request(handleRequest, info) {
          const pathname = utils.getPathFromRequest(info.request);
          const activeSpan = core.getActiveSpan();
          const existingRootSpan = activeSpan ? core.getRootSpan(activeSpan) : undefined;

          if (existingRootSpan) {
            core.updateSpanName(existingRootSpan, `${info.request.method} ${pathname}`);
            existingRootSpan.setAttributes({
              [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
              [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.react_router.instrumentation_api',
              [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
            });

            try {
              const result = await handleRequest();
              if (result.status === 'error' && result.error instanceof Error) {
                existingRootSpan.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.request_handler', {
                  'http.method': info.request.method,
                  'http.url': pathname,
                });
              }
            } finally {
              await core.flushIfServerless();
            }
          } else {
            await core.startSpan(
              {
                name: `${info.request.method} ${pathname}`,
                forceTransaction: true,
                attributes: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.react_router.instrumentation_api',
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                  'http.request.method': info.request.method,
                  'url.path': pathname,
                  'url.full': info.request.url,
                },
              },
              async span => {
                try {
                  const result = await handleRequest();
                  if (result.status === 'error' && result.error instanceof Error) {
                    span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                    utils.captureInstrumentationError(result, captureErrors, 'react_router.request_handler', {
                      'http.method': info.request.method,
                      'http.url': pathname,
                    });
                  }
                } finally {
                  await core.flushIfServerless();
                }
              },
            );
          }
        },
      });
    },

    route(route) {
      route.instrument({
        async loader(callLoader, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const pattern = utils.getPattern(info);
          const routePattern = utils.normalizeRoutePath(pattern) || urlPath;
          updateRootSpanWithRoute(info.request.method, pattern, urlPath);

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.loader',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callLoader();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.loader', {
                  'http.method': info.request.method,
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async action(callAction, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const pattern = utils.getPattern(info);
          const routePattern = utils.normalizeRoutePath(pattern) || urlPath;
          updateRootSpanWithRoute(info.request.method, pattern, urlPath);

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.action',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callAction();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.action', {
                  'http.method': info.request.method,
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async middleware(callMiddleware, info) {
          const urlPath = utils.getPathFromRequest(info.request);
          const pattern = utils.getPattern(info);
          const routePattern = utils.normalizeRoutePath(pattern) || urlPath;

          // Update root span with parameterized route (same as loader/action)
          updateRootSpanWithRoute(info.request.method, pattern, urlPath);

          await core.startSpan(
            {
              name: routePattern,
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.middleware',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callMiddleware();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.middleware', {
                  'http.method': info.request.method,
                  'http.url': urlPath,
                });
              }
            },
          );
        },

        async lazy(callLazy) {
          await core.startSpan(
            {
              name: 'Lazy Route Load',
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.react_router.lazy',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.react_router.instrumentation_api',
              },
            },
            async span => {
              const result = await callLazy();
              if (result.status === 'error' && result.error instanceof Error) {
                span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'internal_error' });
                utils.captureInstrumentationError(result, captureErrors, 'react_router.lazy', {});
              }
            },
          );
        },
      });
    },
  };
}

function updateRootSpanWithRoute(method, pattern, urlPath) {
  const activeSpan = core.getActiveSpan();
  if (!activeSpan) return;
  const rootSpan = core.getRootSpan(activeSpan);
  if (!rootSpan) return;

  // Skip update if URL path is invalid (failed to parse)
  if (!urlPath || urlPath === '<unknown>') {
    debugBuild.DEBUG_BUILD && core.debug.warn('Cannot update span with invalid URL path:', urlPath);
    return;
  }

  const hasPattern = !!pattern;
  const routeName = hasPattern ? utils.normalizeRoutePath(pattern) || urlPath : urlPath;

  const rpcMetadata = core$1.getRPCMetadata(api.context.active());
  if (rpcMetadata?.type === core$1.RPCType.HTTP) {
    rpcMetadata.route = routeName;
  }

  const transactionName = `${method} ${routeName}`;
  core.updateSpanName(rootSpan, transactionName);
  rootSpan.setAttributes({
    [semanticConventions.ATTR_HTTP_ROUTE]: routeName,
    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: hasPattern ? 'route' : 'url',
  });

  // Also update the scope's transaction name so errors captured during this request
  // have the correct transaction name (not the initial placeholder like "GET *")
  core.getCurrentScope().setTransactionName(transactionName);
}

exports.isInstrumentationApiUsed = serverGlobals.isInstrumentationApiUsed;
exports.createSentryServerInstrumentation = createSentryServerInstrumentation;
//# sourceMappingURL=createServerInstrumentation.js.map
