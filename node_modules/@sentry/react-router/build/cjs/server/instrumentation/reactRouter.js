Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const instrumentation = require('@opentelemetry/instrumentation');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const debugBuild = require('../../common/debug-build.js');
const serverGlobals = require('../serverGlobals.js');
const util = require('./util.js');

const supportedVersions = ['>=7.0.0'];
const COMPONENT = 'react-router';

/**
 * Instrumentation for React Router's server request handler.
 * This patches the requestHandler function to add Sentry performance monitoring for data loaders.
 */
class ReactRouterInstrumentation extends instrumentation.InstrumentationBase {
   constructor(config = {}) {
    super('ReactRouterInstrumentation', core.SDK_VERSION, config);
  }

  /**
   * Initializes the instrumentation by defining the React Router server modules to be patched.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
   init() {
    const reactRouterServerModule = new instrumentation.InstrumentationNodeModuleDefinition(
      COMPONENT,
      supportedVersions,
      (moduleExports) => {
        return this._createPatchedModuleProxy(moduleExports);
      },
      (_moduleExports) => {
        // nothing to unwrap here
        return _moduleExports;
      },
    );

    return reactRouterServerModule;
  }

  /**
   * Creates a proxy around the React Router module exports that patches the createRequestHandler function.
   * This allows us to wrap the request handler to add performance monitoring for data loaders and actions.
   */
   _createPatchedModuleProxy(moduleExports) {
    return new Proxy(moduleExports, {
      get(target, prop, receiver) {
        if (prop === 'createRequestHandler') {
          const original = target[prop];
          return function sentryWrappedCreateRequestHandler( ...args) {
            const originalRequestHandler = original.apply(this, args);

            return async function sentryWrappedRequestHandler(request, initialContext) {
              let url;
              try {
                url = new URL(request.url);
              } catch {
                return originalRequestHandler(request, initialContext);
              }

              // We currently just want to trace loaders and actions
              if (!util.isDataRequest(url.pathname)) {
                return originalRequestHandler(request, initialContext);
              }

              // Skip OTEL instrumentation if instrumentation API is being used
              // as it handles loader/action spans itself
              if (serverGlobals.isInstrumentationApiUsed()) {
                debugBuild.DEBUG_BUILD && core.debug.log('Skipping OTEL loader/action instrumentation - using instrumentation API');
                return originalRequestHandler(request, initialContext);
              }

              const activeSpan = core.getActiveSpan();
              const rootSpan = activeSpan && core.getRootSpan(activeSpan);

              if (!rootSpan) {
                debugBuild.DEBUG_BUILD && core.debug.log('No active root span found, skipping tracing for data request');
                return originalRequestHandler(request, initialContext);
              }

              // We cannot rely on the regular span name inferral here, as the express instrumentation sets `*` as the route
              // So we force this to be a more sensible name here
              // TODO: try to set derived parameterized route from build here (args[0])
              const spanData = core.spanToJSON(rootSpan);
              // eslint-disable-next-line deprecation/deprecation
              const target = spanData.data[semanticConventions.SEMATTRS_HTTP_TARGET] || url.pathname;
              core.updateSpanName(rootSpan, `${request.method} ${target}`);
              rootSpan.setAttributes({
                [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.react_router.server',
              });

              return core.startSpan(
                {
                  name: util.getSpanName(url.pathname, request.method),
                  attributes: {
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.react_router.server',
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: util.getOpName(url.pathname, request.method),
                  },
                },
                () => {
                  return originalRequestHandler(request, initialContext);
                },
              );
            };
          };
        }
        return Reflect.get(target, prop, receiver);
      },
    });
  }
}

exports.ReactRouterInstrumentation = ReactRouterInstrumentation;
//# sourceMappingURL=reactRouter.js.map
